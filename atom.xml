<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大丁的技术博客</title>
  
  <subtitle>夜静海涛三万里，月明飞锡下天风</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yudading.github.io/"/>
  <updated>2020-08-13T07:44:42.527Z</updated>
  <id>https://yudading.github.io/</id>
  
  <author>
    <name>大丁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发系统05</title>
    <link href="https://yudading.github.io/2020/08/13/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F05/"/>
    <id>https://yudading.github.io/2020/08/13/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F05/</id>
    <published>2020-08-13T07:27:42.000Z</published>
    <updated>2020-08-13T07:44:42.527Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5212440&auto=1&height=66"></iframe><h2 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h2><h3 id="数据库连接池有两个最重要的配置："><a href="#数据库连接池有两个最重要的配置：" class="headerlink" title="数据库连接池有两个最重要的配置："></a>数据库连接池有两个最重要的配置：</h3><p><strong>最小连接数和最大连接数</strong></p><p><strong>它们控制着从连接池中获取连接的流程：</strong></p><p>-如果当前连接数小于最小连接数，则创建新的连接处理数据库请求；</p><p>-如果连接池中有空闲连接则复用空闲连接；</p><p>-如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求；</p><p>-如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用；</p><p>-如果等待超过了这个设定时间则向用户抛出错误。</p><h3 id="用线程池预先创建线程"><a href="#用线程池预先创建线程" class="headerlink" title="用线程池预先创建线程"></a>用线程池预先创建线程</h3><ul><li>如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；</li><li>如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；</li><li>当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；</li><li>当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。</li></ul><p><img src="/2020/08/13/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F05/3913.png" alt="3913"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="数据库连接池" scheme="https://yudading.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="最小连接数" scheme="https://yudading.github.io/tags/%E6%9C%80%E5%B0%8F%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    
      <category term="最大连接数" scheme="https://yudading.github.io/tags/%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    
      <category term="JDK 线程池提交任务示意图" scheme="https://yudading.github.io/tags/JDK-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统04</title>
    <link href="https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F04/"/>
    <id>https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F04/</id>
    <published>2020-08-11T07:55:36.000Z</published>
    <updated>2020-08-11T08:07:57.568Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2328860&auto=1&height=66"></iframe><h2 id="高可扩展性的设计"><a href="#高可扩展性的设计" class="headerlink" title="高可扩展性的设计"></a>高可扩展性的设计</h2><p>需要站在整体架构的角度，而不仅仅是业务服务器的角度来考虑系统的扩展性，</p><p>数据库、缓存、依赖的第三方、负载均衡、交换机带宽等等都是系统扩展时需要考虑的因素，</p><p>因为系统并发到了某一个量级之后，哪一个因素会成为我们的瓶颈点，从而针对性地进行扩展。</p><ol><li>存储层的扩展性 </li></ol><ul><li><p>存储拆分首先考虑的维度是业务维度</p></li><li><p>统运行时间长了之后，单一的业务数据库在容量和并发请求量上仍然会超过单机的限制。这时，我们就需要针对数据库做第二次拆分。</p></li></ul><ol start="2"><li>业务层的扩展性</li></ol><ul><li>业务维度</li><li>重要性维度</li><li>请求来源维度</li></ul><p>首先，我们需要把相同业务的服务拆分成单独的业务池，</p><p>除此之外，我们还可以根据业务接口的重要程度，把业务分为核心池和非核心池，</p><p>最后，你还可以根据接入客户端类型的不同做业务池的拆分。</p><p><strong>总结：</strong></p><p>未做拆分的系统虽然可扩展性不强，但是却足够简单，无论是系统开发还是运行维护都不需要投入很大的精力。</p><p>拆分之后，需求开发需要横跨多个系统多个小团队，排查问题也需要涉及多个系统，运行维护上，可能每个子系统都需要有专人来负责，对于团队是一个比较大的考验。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="高可扩展性的设计" scheme="https://yudading.github.io/tags/%E9%AB%98%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="存储层的扩展性" scheme="https://yudading.github.io/tags/%E5%AD%98%E5%82%A8%E5%B1%82%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7/"/>
    
      <category term="业务层的扩展性" scheme="https://yudading.github.io/tags/%E4%B8%9A%E5%8A%A1%E5%B1%82%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统03</title>
    <link href="https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F03/"/>
    <id>https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F03/</id>
    <published>2020-08-11T07:30:45.000Z</published>
    <updated>2020-08-11T07:49:23.078Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=20592011&auto=1&height=66"></iframe><h2 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h2><p>指的是系统具备较高的无故障运行的能力</p><h3 id="可用性的度量"><a href="#可用性的度量" class="headerlink" title="可用性的度量"></a>可用性的度量</h3><ul><li>MTBF（Mean Time Between Failure）是平均故障间隔的意思，代表两次故障的间隔时间，也就是系统正常运转的平均时间。这个时间越长，系统稳定性越高</li><li>MTTR（Mean Time To Repair）表示故障的平均恢复时间，也可以理解为平均故障时间。这个值越小，故障对于用户的影响越小</li></ul><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F03/3715.png" alt="3715"></p><h2 id="高可用系统设计的思路"><a href="#高可用系统设计的思路" class="headerlink" title="高可用系统设计的思路"></a>高可用系统设计的思路</h2><ol><li>系统设计</li></ol><p><strong>failover（故障转移</strong>）</p><p>一般来说，发生 failover 的节点可能有两种情况：</p><p>一是在完全对等的节点之间做 failover。</p><p>二是在不对等的节点之间，即系统中存在主节点也存在备节点。</p><p><strong>超时控制</strong></p><p>收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间。</p><p>如果没有调用的日志，那么你只能按照经验值来指定超时时间。</p><p>不过，无论你使用哪种方式，超时时间都不是一成不变的，需要在后面的系统维护过程中不断地修改。</p><p><strong>降级</strong></p><p>降级是为了保证核心服务的稳定而牺牲非核心服务的做法</p><p><strong>限流</strong></p><p>限流完全是另外一种思路，它通过对并发的请求进行限速来保护系统</p><ol start="2"><li>系统运维</li></ol><p><strong>灰度发布</strong></p><p>灰度发布指的是系统的变更不是一次性地推到线上的，而是按照一定比例逐步推进的</p><p><strong>故障演练</strong></p><p>故障演练指的是对系统进行一些破坏性的手段，观察在出现局部故障时，整体的系统表现是怎样的，从而发现系统中存在的，潜在的可用性问题</p><p><strong>开发和运维角度上来看</strong>，提升可用性的方法是不同的：</p><ul><li><p><strong>开发注重的</strong>是如何处理故障，关键词是冗余和取舍。冗余指的是有备用节点，集群来顶替出故障的服务，比如文中提到的故障转移，还有多活架构等等；取舍指的是丢卒保车，保障主体服务的安全。</p></li><li><p><strong>从运维角度来看</strong>则更偏保守，注重的是如何避免故障的发生，比如更关注变更管理以及如何做故障的演练。</p></li></ul><p>两者结合起来才能组成一套完善的高可用体系。</p><p><strong>需要注意的是</strong>：</p><p>提高系统的可用性有时候是以牺牲用户体验或者是牺牲系统性能为前提的，也需要大量人力来建设相应的系统，完善机制。所以我们要把握一个度，不该做过度的优化；</p><p>可用性和性能有时候是需要做取舍的，但如何取舍就要视不同的系统而定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="MTBF" scheme="https://yudading.github.io/tags/MTBF/"/>
    
      <category term="MTTR" scheme="https://yudading.github.io/tags/MTTR/"/>
    
      <category term="failover" scheme="https://yudading.github.io/tags/failover/"/>
    
      <category term="超时控制" scheme="https://yudading.github.io/tags/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/"/>
    
      <category term="降级" scheme="https://yudading.github.io/tags/%E9%99%8D%E7%BA%A7/"/>
    
      <category term="限流" scheme="https://yudading.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="灰度发布" scheme="https://yudading.github.io/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    
      <category term="故障演练" scheme="https://yudading.github.io/tags/%E6%95%85%E9%9A%9C%E6%BC%94%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统02</title>
    <link href="https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F02/"/>
    <id>https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F02/</id>
    <published>2020-08-11T07:09:06.000Z</published>
    <updated>2020-08-11T07:28:16.616Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=3598064&auto=1&height=66"></iframe><h2 id="高并发系统设计的三大目标"><a href="#高并发系统设计的三大目标" class="headerlink" title="高并发系统设计的三大目标"></a>高并发系统设计的三大目标</h2><p>高并发，是指运用设计手段让系统能够处理更多的用户并发请求，也就是承担更大的流量</p><ul><li>高性能 </li><li>高可用</li><li>可扩展</li></ul><h3 id="性能优化原则"><a href="#性能优化原则" class="headerlink" title="性能优化原则"></a>性能优化原则</h3><ul><li>首先，性能优化一定不能盲目，一定是问题导向的</li><li>其次，性能优化也遵循“八二原则”</li><li>再次，性能优化也要有数据支撑</li><li>最后，性能优化的过程是持续的</li></ul><h3 id="性能的度量指标"><a href="#性能的度量指标" class="headerlink" title="性能的度量指标"></a>性能的度量指标</h3><ul><li>平均值</li><li>最大值</li><li>分位值</li></ul><p>通常使用吞吐量或者响应时间来度量并发和流量，使用吞吐量的情况会更多一些</p><h3 id="高并发下的性能优化"><a href="#高并发下的性能优化" class="headerlink" title="高并发下的性能优化"></a>高并发下的性能优化</h3><ol><li>提高系统的处理核心数</li></ol><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F02/1948.png" alt="1948"></p><ol start="2"><li>减少单次任务响应时间</li></ol><p><strong>CPU 密集型</strong>  </p><p>CPU 密集型系统中，需要处理大量的 CPU<br>运算，那么选用更高效的算法或者减少运算次数就是这类系统重要的优化手段</p><p><strong>IO 密集型</strong></p><p>IO 密集型系统指的是系统的大部分操作是在等待 IO 完成，这里 IO 指的是磁盘 IO 和网络<br>IO。大部分都属于 IO 密集型，比如数据库系统、缓存系统、Web 系统。</p><p><strong>第一类</strong>是采用工具，Linux 的工具集很丰富，完全可以满足你的优化需要，比如网络协议栈、网卡、磁盘、文件系统、内存，等等</p><p><strong>另外一类</strong>手段就是可以通过监控来发现性能问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="高性能" scheme="https://yudading.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
      <category term="高可用" scheme="https://yudading.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="可扩展" scheme="https://yudading.github.io/tags/%E5%8F%AF%E6%89%A9%E5%B1%95/"/>
    
      <category term="性能的度量指标" scheme="https://yudading.github.io/tags/%E6%80%A7%E8%83%BD%E7%9A%84%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87/"/>
    
      <category term="CPU 密集型" scheme="https://yudading.github.io/tags/CPU-%E5%AF%86%E9%9B%86%E5%9E%8B/"/>
    
      <category term="IO 密集型" scheme="https://yudading.github.io/tags/IO-%E5%AF%86%E9%9B%86%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统01</title>
    <link href="https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/"/>
    <id>https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/</id>
    <published>2020-08-11T06:37:30.000Z</published>
    <updated>2020-08-11T07:05:23.196Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2313097&auto=1&height=66"></iframe><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p>将整体系统拆分成 N 个层次，每个层次有独立的职责，多个层次协同提供完整的功能</p><h4 id="第一种-MVC-架构"><a href="#第一种-MVC-架构" class="headerlink" title="第一种 MVC 架构"></a>第一种 MVC 架构</h4><p>将整体的系统分成了 Model（模型），View（视图）和 Controller（控制器）三个层次，也就是将用户视图和业务处理隔离开，并且通过控制器连接起来，很好地实现了表现和逻辑的解耦，是一种标准的软件分层架构</p><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/4202.png" alt="4202"></p><h4 id="第二种架构"><a href="#第二种架构" class="headerlink" title="第二种架构"></a>第二种架构</h4><ul><li>表现层</li><li>逻辑层</li><li>数据访问层</li></ul><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/4533.png" alt="4533"></p><h4 id="第三种网络分层"><a href="#第三种网络分层" class="headerlink" title="第三种网络分层"></a>第三种网络分层</h4><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/5244.png" alt="5244"></p><h3 id="分层的好处"><a href="#分层的好处" class="headerlink" title="分层的好处"></a>分层的好处</h3><ul><li>可以简化系统设计，让不同的人专注做某一层次的事情</li><li>可以做到很高的复用</li><li>更容易做横向扩展</li></ul><h2 id="阿里系统的分层"><a href="#阿里系统的分层" class="headerlink" title="阿里系统的分层"></a>阿里系统的分层</h2><ul><li>终端显示层：各端模板渲染并执行显示的层。当前主要是 Velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。</li><li>开放接口层：将 Service 层方法封装成开放接口，同时进行网关安全控制和流量控制等。</li><li>Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li>Service 层：业务逻辑层。</li><li>Manager 层：通用业务处理层。这一层主要有两个作用，其一，你可以将原先 Service 层的一些通用能力下沉到这一层，比如与缓存和存储交互策略，中间件的接入；其二，你也可以在这一层封装对第三方接口的调用，比如调用支付服务，调用审核服务等。</li><li>DAO 层：数据访问层，与底层 MySQL、Oracle、HBase 等进行数据交互。</li><li>外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li></ul><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F01/0058.png" alt="0058"></p><h3 id="分层带来的缺点"><a href="#分层带来的缺点" class="headerlink" title="分层带来的缺点"></a>分层带来的缺点</h3><ul><li>增加了代码的复杂度</li><li>引起性能上的不足</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分层设计的好处" scheme="https://yudading.github.io/tags/%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    
      <category term="分层设计的缺点" scheme="https://yudading.github.io/tags/%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%BC%BA%E7%82%B9/"/>
    
      <category term="阿里系统的分层" scheme="https://yudading.github.io/tags/%E9%98%BF%E9%87%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统00</title>
    <link href="https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F00/"/>
    <id>https://yudading.github.io/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F00/</id>
    <published>2020-08-11T06:15:09.000Z</published>
    <updated>2020-08-11T06:35:11.966Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27102079&auto=1&height=66"></iframe><h1 id="高并发系统"><a href="#高并发系统" class="headerlink" title="高并发系统"></a>高并发系统</h1><h2 id="高并发的重要方法"><a href="#高并发的重要方法" class="headerlink" title="高并发的重要方法"></a>高并发的重要方法</h2><ul><li>横向扩展</li><li>缓存</li><li>异步处理</li></ul><h3 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h3><p>采用分布式部署的方式把流量分流开。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>任何降低响应时间的中间存储都称为缓存。</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。</p><p><strong>那么什么是同步，什么是异步呢？</strong></p><p>以方法调用为例，同步调用代表调用方要阻塞等待被调用方法中的逻辑执行完成。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。</p><p>异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。</p><p><img src="/2020/08/11/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F00/2351.png" alt="2351"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="高并发系统" scheme="https://yudading.github.io/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="横向扩展" scheme="https://yudading.github.io/tags/%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95/"/>
    
      <category term="缓存" scheme="https://yudading.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="异步" scheme="https://yudading.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes03</title>
    <link href="https://yudading.github.io/2020/08/07/Kubernetes03/"/>
    <id>https://yudading.github.io/2020/08/07/Kubernetes03/</id>
    <published>2020-08-07T08:33:20.000Z</published>
    <updated>2020-08-07T08:50:08.126Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=17406299&auto=1&height=66"></iframe><h1 id="Kubernetes布署"><a href="#Kubernetes布署" class="headerlink" title="Kubernetes布署"></a>Kubernetes布署</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>下载安装 k8s 指定的版本</li><li>64 位的 Linux 操作系统、3.10 及以上的内核版本，注意有些linux系统要做内核升级才能安装成功</li><li>拉取镜像要加入阿里的配置镜像链接，否则很慢或失败</li><li>最好2 核 CPU、8 GB 内存以上的配置，用VMware、物理机、云主机均可，但不要太小，否则安装时直接报错</li></ul><h2 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h2><ul><li>在所有节点上安装 Docker 和 kubeadm；可选择工具安装和二进制安装，但生产中不建义用二进制</li><li>部署 Kubernetes Master；可以是一个节点，生产中建义用集群</li><li>部署容器网络插件；一定要安装网络插件，否则无法访问</li><li>部署 Kubernetes Worker；</li><li>部署 Dashboard 可视化插件；可视化插件有一个Web本看界面，虽然一直在完善</li><li>部署容器存储插件，一定要用的</li></ul><p>安装中用编写YAML文件，用工具生成就可以了，具体实现安装我会稍后把文档分享给大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://yudading.github.io/categories/Kubernetes/"/>
    
    
      <category term="k8s布署" scheme="https://yudading.github.io/tags/k8s%E5%B8%83%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes02</title>
    <link href="https://yudading.github.io/2020/08/07/Kubernetes02/"/>
    <id>https://yudading.github.io/2020/08/07/Kubernetes02/</id>
    <published>2020-08-07T08:00:06.000Z</published>
    <updated>2020-08-07T08:22:06.378Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=18688793&auto=1&height=66"></iframe><p>大家好，我是大丁，接着聊一下 Kubernetes 的本质是什么？</p><h1 id="Kubernetes本质"><a href="#Kubernetes本质" class="headerlink" title="Kubernetes本质"></a>Kubernetes本质</h1><h2 id="容器实现技术"><a href="#容器实现技术" class="headerlink" title="容器实现技术"></a>容器实现技术</h2><p>三种技术构建出来的进程的隔离环境：</p><ul><li>Linux Namespace、</li><li>Linux Cgroups </li><li>rootfs </li></ul><p>容器其实可以分为两个部分：容器运行时和容器镜像</p><p>一个正在运行的 Linux 容器，其实可以被“一分为二”地看待：</p><ul><li>一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</li><li>一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</li></ul><h2 id="k8s设计思想"><a href="#k8s设计思想" class="headerlink" title="k8s设计思想"></a>k8s设计思想</h2><p>从宏观的角度用统一的方式定义任务之间的关系</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li>Master 控制节点</li><li>Node 计算节点</li></ul><p>Master 节点，由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的 kube-scheduler，以及负责容器编排的 kube-controller-manager。</p><p>整个集群的持久化数据，则由 kube-apiserver 处理后保存在 Etcd 中。</p><p>计算节点上最核心的部分，则是一个叫作 kubelet 的组件。</p><h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><ul><li>kubelet 主要负责同容器运行时（比如 Docker 项目）打交道</li><li>kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互。</li><li>调用网络插件和存储插件为容器配置网络和持久化存储。</li></ul><p><strong>Kubernetes 运行在Docker之上，它 的本质，是为用户提供一个具有普遍意义的容器编排工具</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://yudading.github.io/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes 本质" scheme="https://yudading.github.io/tags/Kubernetes-%E6%9C%AC%E8%B4%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes01</title>
    <link href="https://yudading.github.io/2020/08/07/Kubernetes01/"/>
    <id>https://yudading.github.io/2020/08/07/Kubernetes01/</id>
    <published>2020-08-07T07:30:24.000Z</published>
    <updated>2020-08-07T07:56:42.785Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=17245428&auto=1&height=66"></iframe><p>大家好，我是大丁，一起看一下K8S的知识图谱。</p><h1 id="K8S的知识图谱"><a href="#K8S的知识图谱" class="headerlink" title="K8S的知识图谱"></a>K8S的知识图谱</h1><ul><li>Container basics 容器基础技术</li><li>Kubernetes 作业管理</li><li>Kubernetes 应用配置</li><li>Kubernetes 安装与运维</li><li>Kubernetes 扩展与插件</li><li>Kubernetes CI/CD</li><li>Kubernetes Paas</li><li>Kubernetes 架构（Kubelet and Master）</li></ul><p><img src="/2020/08/07/Kubernetes01/4514.png" alt="4514"></p><p><strong>图片链接：</strong></p><p><a href="https://time.geekbang.org/column/article/17921" target="_blank" rel="noopener">k8s知识图谱链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://yudading.github.io/categories/Kubernetes/"/>
    
    
      <category term="知识图谱" scheme="https://yudading.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes00</title>
    <link href="https://yudading.github.io/2020/08/07/Kubernetes/"/>
    <id>https://yudading.github.io/2020/08/07/Kubernetes/</id>
    <published>2020-08-07T06:56:00.000Z</published>
    <updated>2020-08-07T07:27:09.638Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1374656&auto=1&height=66"></iframe><p>您好，我是大丁，这次聊聊最火的发展方向 Kubernetes。</p><h1 id="起源于容器"><a href="#起源于容器" class="headerlink" title="起源于容器"></a>起源于容器</h1><p>容器是一种沙盒，如同集装箱，把应用装起来的一种技术，而对于容器中的所有应用都保持相对的独立，互相无干扰，使用哪个应用就用哪个，不受制别的应用。</p><h2 id="容器的实现"><a href="#容器的实现" class="headerlink" title="容器的实现"></a>容器的实现</h2><p>容器本质上依然是一个单进程，采用Cgroups来进行约束，Namespace修改进程。</p><p>Cgroups 即 Linux Control Group，主要作用就是限制一个进程组能使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。它的每个子系统也有资源限制的能力，可以限制 blkio、cpuset、memory。</p><ul><li>blkio 为块设备设定I/O限制，一般用于磁盘</li><li>cpuset 为进程分配单独的CPU核和对应的内存节点</li><li>memory 为进程设定内存使用的限制</li></ul><p>Namespace 修改应用进程，被操作系统做了限制，来看指定的内容。</p><h2 id="容器的优点"><a href="#容器的优点" class="headerlink" title="容器的优点"></a>容器的优点</h2><ul><li>敏捷</li><li>高性能</li></ul><h2 id="rootfs（根文件系统）"><a href="#rootfs（根文件系统）" class="headerlink" title="rootfs（根文件系统）"></a>rootfs（根文件系统）</h2><p>rootfs 即容器镜像，rootfs<br>只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。</p><p>在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p><h3 id="rootfs-功能"><a href="#rootfs-功能" class="headerlink" title="rootfs 功能"></a>rootfs 功能</h3><p>保持容器的一致性</p><h3 id="rootfs-包括三部分："><a href="#rootfs-包括三部分：" class="headerlink" title="rootfs 包括三部分："></a>rootfs 包括三部分：</h3><ul><li>只读层</li><li>可读写层</li><li>Init层</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://yudading.github.io/categories/Kubernetes/"/>
    
    
      <category term="容器" scheme="https://yudading.github.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构01</title>
    <link href="https://yudading.github.io/2020/08/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://yudading.github.io/2020/08/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-08-07T02:26:47.000Z</published>
    <updated>2020-08-07T03:12:49.700Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2423350&auto=1&height=66"></iframe><p>您好，我是大丁，今天说一说算法和数据结构。</p><p>我打赌写程序的你，包括你身边的，可能对算法和数据结构的掌握情况可以只限于“学过”。 而且很多人在工作中都几乎不用，编好的程序只要没有bug，能运行，功能上能实现就算是OK了。</p><p>从来没有想过怎么优化代码，上线后是否会对服务器造成多大的影响，都不会认真考虑，我为什么知道呢？因为我做过运维，哈哈！</p><p>数据结构和算法是一项基本功，学好了无往不利。这是让人提升的一项利器，也是你能从一帮平凡程序员中挣脱出来站在一定高度的至宝，所以极有必要好好掌握到最佳。</p><p>所以大厂面试时都会问到，如果你想去大厂，那么还等什么呢？</p><h2 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h2><p>数据结构就是针对数据存储的一种形式，算法就是如何操作这些形式的数据。要不同条件下，同一段代码可能产生不同的时间复杂度、空间复杂度，所以要选最优。</p><h2 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h2><p>了解基本理论后就要不断的动手，去刷题吧！</p><h2 id="大-O-时间复杂度表示法"><a href="#大-O-时间复杂度表示法" class="headerlink" title="大 O 时间复杂度表示法"></a>大 O 时间复杂度表示法</h2><p>大 O 表示法就是指出算法的速度有多快，程序中采用不同的逻辑可以造成不一样的运行时间。</p><h3 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h3><p>总复杂度等于量级最大的那段代码的复杂度</p><h3 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h3><p>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><h3 id="复杂度量级"><a href="#复杂度量级" class="headerlink" title="复杂度量级"></a>复杂度量级</h3><p><img src="/2020/08/07/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/0313.png" alt="0313"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</p><ul><li>最好情况时间复杂度（best case time complexity）</li><li>最坏情况时间复杂度（worst case time complexity）</li><li>平均情况时间复杂度（average case time complexity）</li><li>均摊时间复杂度（amortized time complexity）。</li></ul><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://yudading.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="大O" scheme="https://yudading.github.io/tags/%E5%A4%A7O/"/>
    
      <category term="时间复杂度" scheme="https://yudading.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="空间复杂度" scheme="https://yudading.github.io/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据中台01</title>
    <link href="https://yudading.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B001/"/>
    <id>https://yudading.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B001/</id>
    <published>2020-08-06T03:47:28.000Z</published>
    <updated>2020-08-06T04:35:23.846Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=16661917&auto=1&height=66"></iframe><p>您好，我是大丁，和大家说说数据中台。</p><p>中台近几年兴起，搞技术的人对什么是中台都有个自的看法和想法，我这里简单说说。</p><h2 id="中台的出现"><a href="#中台的出现" class="headerlink" title="中台的出现"></a>中台的出现</h2><p>中台这个词最早来自2015年的阿里的战略概念，原因是马云拜访了一家芬兰的公司Supercell,而这家公司采用了一种“开发者领导”模式，就是细分小团队来开发游戏，提高速度推出公测版，可以说这是一种组织结构的重组和变革方式。</p><h2 id="中台能做什么？"><a href="#中台能做什么？" class="headerlink" title="中台能做什么？"></a>中台能做什么？</h2><p>可以理解是前台与后台中间的一个协调，转化前方市场与内部支撑的冲突，在前台与后台之间做一个战略性的缓冲和加固，它可以打破企业内部的壁垒，加大提高效率。中台分很多，有业务中台、组织中台、数据中台等等。都是针对某一方面基本理念不变的情况下做出的一种改革。本质上来说，依然是一种服务。</p><p>举个例子，现在猪肉价钱不低，市场不错，有需求量，所以你决定养猪，这样你要了解市场</p><ul><li>什么样的人对猪肉需要量高</li><li>超市需要什么样处理的猪肉</li><li>菜市场需要什么样的猪肉</li><li>有哪些工厂对猪肉再次做再加工</li><li>哪个地区的需求量高而且还有特殊要求</li></ul><p>凡此等等，都是前方前台的一系列要求</p><p>了解了需求以后就要计算自己的能力有多大？能做成什么规模，是不是要针对某一类人做生产，还是对所有消费者都提供猪肉呢？都要计算到。</p><p>这时就要看自己是家庭形式养猪呢，还是做工厂招大量的员工来养猪，这里就要做好前期的投入，人员的培训，做章程，等等很多工作了。</p><p>针对消费者，是不是只负责养猪，还是做一条龙的服务呢？对于超市的需求我们做一条线，对于菜市场的人也需要一条生产线，但是怎么能最大化提高效率呢？这就是中台。</p><p>可以想像为前台有种种不断的要求，中台就像一块海棉，吸收进来后还要排出去给生产的所有相关环节，不只是一种简单的对接，而且对所以需要进行计算，细化，分类，转接成一种标准。</p><p>举了一个养猪的例子做一个类比吧，如果你参加中台建设落地后，想必你对中台会有更深的理解。</p><h2 id="数据中台不是数据平台"><a href="#数据中台不是数据平台" class="headerlink" title="数据中台不是数据平台"></a>数据中台不是数据平台</h2><p>数据中台不是数据平台，数据平台提供了是各种结构化、非结构化的数据集，而数据中台是在数据平台之上，完成企业数据到业务价值的转变。</p><h2 id="数据中台与微服务"><a href="#数据中台与微服务" class="headerlink" title="数据中台与微服务"></a>数据中台与微服务</h2><p>数据中台方向上为了满足前端带来的各种需求；而微服务是后端各种对象的整合。</p><h2 id="对于中台的定义"><a href="#对于中台的定义" class="headerlink" title="对于中台的定义"></a>对于中台的定义</h2><p>ThoughtWorks首席咨询师王健对中台的定义是：<strong>企业级能力复用平台</strong>，它包括：企业级、能力、复用及平台。</p><ul><li>企业级说明了中台范围</li><li>能力说明了承载的对象</li><li>复用说明了中台的核心价值</li><li>平台说明了中台的主要形式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="数据中台" scheme="https://yudading.github.io/categories/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/"/>
    
    
      <category term="什么是中台" scheme="https://yudading.github.io/tags/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记-01</title>
    <link href="https://yudading.github.io/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://yudading.github.io/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</id>
    <published>2020-08-05T13:52:41.000Z</published>
    <updated>2020-08-05T14:22:54.792Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1466027974&auto=1&height=66"></iframe><h1 id="玩转C语言程序设计-01"><a href="#玩转C语言程序设计-01" class="headerlink" title="玩转C语言程序设计_01"></a>玩转C语言程序设计_01</h1><p>大家好，我是大丁，本系列记录为学习C语言的笔记，下面的代码和笔记都来自于《玩转C语言程序设计》这本书，此系列笔记只用于学习交流。</p><p><img src="/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/114.png" alt="114"></p><h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><h3 id="1-puthchar-函数"><a href="#1-puthchar-函数" class="headerlink" title="1 puthchar() 函数"></a>1 puthchar() 函数</h3><p>每次只能向显示输出设备输出单个字符，该函数的原型包含在stdio.h头文件中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int putchar(int ch);</span><br></pre></td></tr></table></figure><h4 id="实例01-输出“小猪”表情"><a href="#实例01-输出“小猪”表情" class="headerlink" title="实例01 输出“小猪”表情"></a>实例01 输出“小猪”表情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char c1 &#x3D; &#39;(&#39;,c2 &#x3D; &#39;-&#39;,c3 &#x3D; &#39;o&#39;,c4 &#x3D; &#39;)&#39;;</span><br><span class="line">putchar(c1);</span><br><span class="line">putchar(c2);</span><br><span class="line">putchar(c1);</span><br><span class="line">putchar(c3);</span><br><span class="line">putchar(c3);</span><br><span class="line">putchar(c4);</span><br><span class="line">putchar(c2);</span><br><span class="line">putchar(c4);</span><br><span class="line">putchar(&#39;\n&#39;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看"><a href="#运行查看" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./01</strong> </p><blockquote><p>(-(oo)-)</p></blockquote><hr><h3 id="2-puts-函数"><a href="#2-puts-函数" class="headerlink" title="2 puts() 函数"></a>2 puts() 函数</h3><p>一次可以输出多个字符，可用来输出一个字符串到显示屏幕上，它也在stdio.h的函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int puts(char *str);</span><br></pre></td></tr></table></figure><h4 id="实例02-跟我一起来说绕口令"><a href="#实例02-跟我一起来说绕口令" class="headerlink" title="实例02 跟我一起来说绕口令"></a>实例02 跟我一起来说绕口令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;粉红墙上事凤凰，凤凰画在粉红墙&quot;);</span><br><span class="line">puts(&quot;红凤凰、粉凤凰，红粉凤凰、花凤凰&quot;);</span><br><span class="line">puts(&quot;红凤凰、黄凤凰，红粉凤凰，粉红凤凰，花粉花凤凰&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-1"><a href="#运行查看-1" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./02</strong></p><p>粉红墙上事凤凰，凤凰画在粉红墙</p><p>红凤凰、粉凤凰，红粉凤凰、花凤凰</p><p>红凤凰、黄凤凰，红粉凤凰，粉红凤凰，花粉花凤凰</p><hr><h3 id="3-printf-函数"><a href="#3-printf-函数" class="headerlink" title="3 printf() 函数"></a>3 printf() 函数</h3><p>是控制格式的输出函数，也在stdio.h函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(格式控制，输出列表)；</span><br></pre></td></tr></table></figure><ol><li>格式控制是用双引号括起来的字符串，此处也称为转换控制字符串，其中包括格式字符和普通字符两种格式。</li></ol><ul><li>格式字符用来对格式进行说明，其作用是将输出的数据转换为指定的格式输出。格式字符以“%”字符开头。</li><li>普通字符是需要按照原样输出的字符，其中包括双引号内的逗号、空格和换行符。</li></ul><ol start="2"><li>输出列表</li></ol><p>输出列表框列出的是要进行输出的一些数据，其形式可以是变量或表达式。<br>例如，要输出一个整型变量的语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int iInt &#x3D; 521;</span><br><span class="line">printf(&quot;%d I love You&quot;, iInt);</span><br></pre></td></tr></table></figure><p>执行上面的语句显示结果是“521 I Love You”, 其中 I Love You 是普通字符串，而“%d”就格式字符，表示输出的是后面的iInt的数据。</p><h4 id="实例03-鸡兔同笼问题"><a href="#实例03-鸡兔同笼问题" class="headerlink" title="实例03 鸡兔同笼问题"></a>实例03 鸡兔同笼问题</h4><p>鸡、兔关在同一个笼子里，已知有35个头、94只脚，问笼子里有几只鸡、几只兔。计算代码如下：</p><p>鸡的数量 =（4*鸡兔总头数 - 鸡兔总脚数）/2； 兔的数量 = （鸡兔总脚数 - 2 * 鸡兔总头数）/2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int feet&#x3D;94,head&#x3D;35,Chicken,Rabbit;</span><br><span class="line">Chicken &#x3D; (4 * head - feet) &#x2F; 2;</span><br><span class="line">Rabbit &#x3D; (feet - 2 * head) &#x2F; 2;</span><br><span class="line">printf(&quot;笼中有%d只鸡，有%d只兔子！\n&quot;, Chicken,Rabbit);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-2"><a href="#运行查看-2" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./03</strong></p><p>笼中有23只鸡，有12只兔子！</p><hr><h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><h3 id="1-getchar-函数"><a href="#1-getchar-函数" class="headerlink" title="1 getchar() 函数"></a>1 getchar() 函数</h3><p>每次只能从终端（输入设备）输入一个字符，这个函数的原型包括在stdio.h头文件中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getchar();</span><br></pre></td></tr></table></figure><p>getchar()函数与puthchar()函数的区别是前者没有参数，例如从输入设备得到一个字符给字符变量cChar,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cChar&#x3D;getchar();</span><br></pre></td></tr></table></figure><h4 id="实例04-字母大小写的秘密"><a href="#实例04-字母大小写的秘密" class="headerlink" title="实例04 字母大小写的秘密"></a>实例04 字母大小写的秘密</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char c1,c2;</span><br><span class="line">printf(&quot;请输入一个小写字母：\n&quot;);</span><br><span class="line">c1 &#x3D; getchar();</span><br><span class="line">c2 &#x3D; c1 - 32;</span><br><span class="line">printf(&quot;转换以后的字母：%c\n&quot;, c2);</span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-3"><a href="#运行查看-3" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./04</strong></p><p>请输入一个小写字母：<br>a<br>转换以后的字母：A</p><hr><h3 id="2-get-函数"><a href="#2-get-函数" class="headerlink" title="2 get()函数"></a>2 get()函数</h3><p>get()函数也是输入函数，它能向终端输入一个字符串，该函数也在stdio.h的函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><p>其中str字符串指针变量为形式参数，作用是将读取的字符串保存在形式参数str变量中。例如，定义字符数组变量cString,然后使用gets()函数获取输入字符的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(cString);</span><br></pre></td></tr></table></figure><h4 id="实例05-模拟用户登录"><a href="#实例05-模拟用户登录" class="headerlink" title="实例05 模拟用户登录"></a>实例05 模拟用户登录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char cString[20];</span><br><span class="line">puts(&quot;请输入账号：&quot;);</span><br><span class="line">gets(cString);</span><br><span class="line">puts(&quot;您输入的账号为：&quot;);</span><br><span class="line">puts(cString);</span><br><span class="line">puts(&quot;请输入密码：&quot;);</span><br><span class="line">gets(cString);</span><br><span class="line">puts(&quot;您输入的密码为: &quot;);</span><br><span class="line">puts(cString);</span><br><span class="line">puts(&quot;您的账号登录为：&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-4"><a href="#运行查看-4" class="headerlink" title="运行查看"></a>运行查看</h4><blockquote><p>05.c:7:2: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’?</p></blockquote><p>[-Wimplicit-function-declaration]<br>    7 |  gets(cString);<br>      |  ^<del>~</del><br>      |  fgets</p><p>/usr/bin/ld: /tmp/ccUgXpJA.o: in function <code>main&#39;:05.c:(.text+0x34): warning: the</code>gets’ function is dangerous and should not be used.</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>gets是从标准输入设备读取字符串的函数，函数原型 char * gets ( char * str );  刚开始学习C语言时觉得gets这个函数相当的好用，因为他比scanf写起来要短，而且可以输入有空格的字符串。但是越往后学就会发现，在C语言中用GCC编译使用了gets函数的源文件，编译器会给警告。<br>原因是gets可以无限读取，不会判断上限，如果无限输入会造成栈空间溢出，在程序返回时，不能正常的找到返回地址，程序将发生不可预测行为。如果用了gets，像我们现在写的小程序可能在PC端上会闪退，但如果在大型项目中就会造成很严重的损失。因此我们应该尽量避免使用gets函数，顺便一提在2011年12月，ANSI 采纳了 ISO/IEC 9899:2011 标准，标准中删除了 gets()函数，使用一个新的更安全的函数gets_s()替代。<br>————————————————<br>版权声明：本文为CSDN博主「画地」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42201172/article/details/81259229" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42201172/article/details/81259229</a></p><hr><h3 id="3-scanf-函数"><a href="#3-scanf-函数" class="headerlink" title="3 scanf() 函数"></a>3 scanf() 函数</h3><p>功能是指定固定的格式，并且按照指定的格式接收用户在键盘上输入的数据，最后将数据存储在指定的变量中。一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(格式控制，地址列表);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d,&amp;iInt&quot;);</span><br></pre></td></tr></table></figure><p>“&amp;”符号表示取iInt变量的地址，在编写代码时不用关心变量的地址具体是多少，只要在代码中变量的标识符前加”&amp;”就表示获取变量的地址。</p><h4 id="实例06-用C程序输出《拍手歌》"><a href="#实例06-用C程序输出《拍手歌》" class="headerlink" title="实例06 用C程序输出《拍手歌》"></a>实例06 用C程序输出《拍手歌》</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int beat;</span><br><span class="line">puts(&quot;请输入你想拍几：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;beat);</span><br><span class="line">printf(&quot;你拍%d, 我拍%d\n&quot;, beat, beat);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-5"><a href="#运行查看-5" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./06</strong></p><p>请输入你想拍几：</p><p>1</p><p>你拍1, 我拍1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="C语言学习笔记" scheme="https://yudading.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="玩转C语言程序设计" scheme="https://yudading.github.io/tags/%E7%8E%A9%E8%BD%ACC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="玩转C语言程序设计chapter1" scheme="https://yudading.github.io/tags/%E7%8E%A9%E8%BD%ACC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1chapter1/"/>
    
  </entry>
  
  <entry>
    <title>性能调优01</title>
    <link href="https://yudading.github.io/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/"/>
    <id>https://yudading.github.io/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/</id>
    <published>2020-08-05T13:19:35.000Z</published>
    <updated>2020-08-05T14:23:20.602Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29004400&auto=0&height=66"></iframe><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><p>您好，我是大丁，这次和大家聊聊有关性能调忧，性能调优是一个很大的领域也包括了很多相关的概念，今天先说三个重要的概念，就是进程、线程、和协程。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p></blockquote><blockquote><p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></blockquote><blockquote><p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 [3]<br>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>操作系统引入进程的概念的原因:</strong><br>从理论角度看，是对正在运行的程序过程的抽象；<br>从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。<br>特征</p><ul><li>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li><li>结构特征：进程由程序、数据和进程控制块三部分组成。</li></ul><p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。<br>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；</p><p>由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。</p><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p><p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><h3 id="与进程比较"><a href="#与进程比较" class="headerlink" title="与进程比较"></a>与进程比较</h3><p><strong>线程与进程的区别可以归纳为以下4点：</strong></p><ol><li>地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li>在多线程OS中，进程不是一个可执行的实体。</li></ol><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>协程</strong>不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。</p><p>一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。</p><p>我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，<br>但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</p><p>看一下三者的关系：</p><p><img src="/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/2058.png" alt="2058"></p><h3 id="举生活中的例子"><a href="#举生活中的例子" class="headerlink" title="举生活中的例子"></a>举生活中的例子</h3><p><strong>进程、线程、协程对比 :</strong></p><ul><li><p>有一个老板想要开个工厂进行生产某件商品（例如剪子）</p></li><li><p>他需要花一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的为了能够生产剪子而准备的资源称之为：进程</p></li><li><p>只有生产线是不能够进行生产的，所以老板的找个工人来进行生产，这个工人能够利用这些材料最终一步步的将剪子做出来，这个来做事情的工人称之为：线程</p></li><li><p>这个老板为了提高生产率，想到3种办法：</p></li></ul><p>在这条生产线上多招些工人，一起来做剪子，这样效率是成倍増长，即单进程 多线程方式</p><p>老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了些财力物力购置了另外一条生产线，然后再招些工人这样效率又再一步提高了，即多进程 多线程方式</p><p>老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时临时没事或者再等待某些条件（比如等待另一个工人生产完某道工序之后他才能再次工作）。</p><p>那么这个员工就利用这个时间去做其它的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：<strong>协程方式</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>准备工作：创建一个APP，延迟3秒后输出‘hello’.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask     # pip install flask</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)    # 休眠 3 秒再返回结果</span><br><span class="line">    return &#39;Hello!&#39;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run(threaded&#x3D;True)  # 以多线程模式启动服务</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"># 用于多进程</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"># 用于多线程</span><br><span class="line">from threading import Thread</span><br><span class="line"># 用于协程+异步</span><br><span class="line">import asyncio</span><br><span class="line">import aiohttp      # pip install aiohttp</span><br><span class="line"></span><br><span class="line">urls &#x3D; [&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39; for _ in range(10)]</span><br><span class="line"></span><br><span class="line">def get_html_text(url):</span><br><span class="line">    response &#x3D; requests.get(url)</span><br><span class="line">    return response.text</span><br><span class="line"></span><br><span class="line"># 单进程</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">for url in urls:</span><br><span class="line">    result &#x3D; get_html_text(url)</span><br><span class="line">    print(result)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【单进程单线程】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 多进程 + 并行</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">processes &#x3D; []</span><br><span class="line">for url in urls:</span><br><span class="line">    p &#x3D; Process(target&#x3D;get_html_text, args&#x3D;(url,))</span><br><span class="line">    processes.append(p)</span><br><span class="line">    p.start()</span><br><span class="line">for p in processes:</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;Hello!&#39;)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【多进程  并行】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 多线程 + 并发</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">threads &#x3D; []</span><br><span class="line">for url in urls:</span><br><span class="line">    t &#x3D; Thread(target&#x3D;get_html_text, args&#x3D;(url,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">    print(&#39;Hello!&#39;)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【多线程  并发】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 协程 + 异步</span><br><span class="line"># 因为 requests 模块不支持异步操作，需要借助 aiohttp 模块</span><br><span class="line">async def get_html_text_async(url):</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        async with session.get(url) as response:</span><br><span class="line">            text &#x3D; await response.text()</span><br><span class="line">            return text</span><br><span class="line"></span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">tasks &#x3D; [asyncio.ensure_future(get_html_text_async(url)) for url in urls]</span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">for task in tasks:</span><br><span class="line">    print(task.result())</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【协程 ++ 异步】耗时：%s 秒&#39; %(end - start))</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【单进程单线程】耗时：30.076159238815308 秒</span><br><span class="line">【多进程  并行】耗时：31.149558782577515 秒</span><br><span class="line">【多线程  并发】耗时：3.0131824016571045 秒</span><br><span class="line">【协程 ++ 异步】耗时：3.0092201232910156 秒</span><br></pre></td></tr></table></figure><h3 id="相关内容链接"><a href="#相关内容链接" class="headerlink" title="相关内容链接"></a>相关内容链接</h3><p><a href="https://blog.csdn.net/hairetz/article/details/16119911" target="_blank" rel="noopener">csdn</a></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">csdn</a></p><p><a href="https://juejin.im/post/6844903607892967432" target="_blank" rel="noopener">掘金</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="性能调优01" scheme="https://yudading.github.io/categories/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/"/>
    
    
      <category term="进程" scheme="https://yudading.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="https://yudading.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="协程" scheme="https://yudading.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>DevOps_01 DevOps是什么？</title>
    <link href="https://yudading.github.io/2020/07/22/DevOps-01/"/>
    <id>https://yudading.github.io/2020/07/22/DevOps-01/</id>
    <published>2020-07-21T16:30:23.000Z</published>
    <updated>2020-07-21T17:50:42.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>大家好，我是大丁，很高兴在这里和大家聊聊DevOps，2020年对我而言是如此地深刻，不只是疫情的原因，虽然在家里有了一些自己的时间，不用每天早起站公交挤地铁，可是人一旦休息久了也会心生厌倦，不过也好，最少有时间让自己放松起来，想想这些年的工作过往，自己做了什么，有哪些收获？技术上提高了多少？踏过多少的坑？就此，与有缘的你分享一下我的过往吧，如果你同我如前浪，望指正，如你是后浪，如你看过我的文字能有收获，那我就很开心了！</p><h1 id="DevOps是什么？"><a href="#DevOps是什么？" class="headerlink" title="DevOps是什么？"></a>DevOps是什么？</h1><h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><blockquote><p>DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>DevOps是外来品，有着太多的属性，下面说说我的个人理解，DevOps它是一种工作方式也是一种文化，对企业而言，它可能是一个团队，也可能是一种口号，可以是公司正在招聘的一个职位，可以是你必须使用的一套相关的工具，可以是技术人员要达到的一种目标，总之，近几年，这个DevOps大火，互联网也好，物联网也罢，如果不选择DevOps，只能说明你所在的公司落后了，要不就是技术人员太low了。</p><p>它包含了不只是通过开发与运维的紧密合作来提高效率，还包括了相关的持续集成、持续发布相关的技术和工具，它需要持续改善的运维架构等等，而这一切都要在结合企业业务的真正实践上，并且你只能借鉴别人，但不能照搬，因为没有哪两个公司是一模一样的。</p><p>我的团队对外就是DevOps，在我的团队中的同事以前有的是做纯开发工作的，也有是做传统运维的，而DevOps的出现，模糊了二者之间的界线，与以前开发与运维关系完全不同，在公司中我做为运维人员要不断的对接开发同事，不只是为他们搭建开发、升级、发布的环境，也要做过上线后的维护，而对开发人员也要和我保持有效的沟通，以便让他们的代码迅速上线。<br>举个真实的过往例子，早期我负责升级工作，当时公司有小三十个服务，它们之间有很强的耦合，当时还是处在脚本化的情况下，我写好了脚本对开发同事的代码进行解包，打包，上传AWS存储，再利用相关的命令行提交服务器等等一系列操作，记得有一天有四十多次升级，是的，四十多次，那天我几乎没做别的工作，一直做升级的事，升级后还要看是否升级成功，服务是否有问题，那天的工作量一想起来就有些上头。</p><p>痛过了，才让人思考，怎么才能减少这种工作量呢？如何自动化升级，怎么样才能让开发人员做一些操作，让运维人员把更多的精力放在维护上呢？如何让开发人员做一些升级的工作他们愿意吗？有些开发人员会觉得只要我代码没问题交给运维就好，出了问题都是运维的责任，这样也造成了开发与运维的恶化关系，所以那时我的工作重点放在了和开发人员好好的沟通上，说明白了相互的具体操作，让公司技术老大来推动，把所有相关的操作编写成文档，明确了各自的责任，同时优化了升级流程，选用了主流的开源工具。</p><p>这样一切规范下来，就不那么痛苦了。在那个时候我对DevOps的体会就是：在现在快速迭代的大环境下，为了提高生产效率，需要两者紧密的合作，说白了<strong>就是想办法减少开发与运维之间的隔阂带来的消耗，提高开发速度，快速上线，不断迭代，它需要开发与运维人员之间良好的沟通</strong>。</p><p>随着工作的不断深入，我也有了更深的体会，现在让我说DevOps到底是什么呢？</p><p>在这里我想说<strong>DevOps解决的是人与人之间的关系，即Dev（开发）和Ops（运维），就是利用相互灵活的关系完成流程化、工具的不断优化，强调精益，减少浪费，快速交付，提供给用户功能体验</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;大家好，我是大丁，很高兴在这里和大家聊聊DevOps，2020年对我而言是如此地深刻，不只是疫情的原因，虽然在家里有了一些自己的时间，不用每
      
    
    </summary>
    
    
      <category term="DevOps" scheme="https://yudading.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://yudading.github.io/tags/DevOps/"/>
    
      <category term="DevOps是什么？" scheme="https://yudading.github.io/tags/DevOps%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    
  </entry>
  
</feed>
