<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大丁的技术博客</title>
  
  <subtitle>夜静海涛三万里，月明飞锡下天风</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yudading.github.io/"/>
  <updated>2020-08-06T04:35:23.846Z</updated>
  <id>https://yudading.github.io/</id>
  
  <author>
    <name>大丁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据中台01</title>
    <link href="https://yudading.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B001/"/>
    <id>https://yudading.github.io/2020/08/06/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B001/</id>
    <published>2020-08-06T03:47:28.000Z</published>
    <updated>2020-08-06T04:35:23.846Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=16661917&auto=1&height=66"></iframe><p>您好，我是大丁，和大家说说数据中台。</p><p>中台近几年兴起，搞技术的人对什么是中台都有个自的看法和想法，我这里简单说说。</p><h2 id="中台的出现"><a href="#中台的出现" class="headerlink" title="中台的出现"></a>中台的出现</h2><p>中台这个词最早来自2015年的阿里的战略概念，原因是马云拜访了一家芬兰的公司Supercell,而这家公司采用了一种“开发者领导”模式，就是细分小团队来开发游戏，提高速度推出公测版，可以说这是一种组织结构的重组和变革方式。</p><h2 id="中台能做什么？"><a href="#中台能做什么？" class="headerlink" title="中台能做什么？"></a>中台能做什么？</h2><p>可以理解是前台与后台中间的一个协调，转化前方市场与内部支撑的冲突，在前台与后台之间做一个战略性的缓冲和加固，它可以打破企业内部的壁垒，加大提高效率。中台分很多，有业务中台、组织中台、数据中台等等。都是针对某一方面基本理念不变的情况下做出的一种改革。本质上来说，依然是一种服务。</p><p>举个例子，现在猪肉价钱不低，市场不错，有需求量，所以你决定养猪，这样你要了解市场</p><ul><li>什么样的人对猪肉需要量高</li><li>超市需要什么样处理的猪肉</li><li>菜市场需要什么样的猪肉</li><li>有哪些工厂对猪肉再次做再加工</li><li>哪个地区的需求量高而且还有特殊要求</li></ul><p>凡此等等，都是前方前台的一系列要求</p><p>了解了需求以后就要计算自己的能力有多大？能做成什么规模，是不是要针对某一类人做生产，还是对所有消费者都提供猪肉呢？都要计算到。</p><p>这时就要看自己是家庭形式养猪呢，还是做工厂招大量的员工来养猪，这里就要做好前期的投入，人员的培训，做章程，等等很多工作了。</p><p>针对消费者，是不是只负责养猪，还是做一条龙的服务呢？对于超市的需求我们做一条线，对于菜市场的人也需要一条生产线，但是怎么能最大化提高效率呢？这就是中台。</p><p>可以想像为前台有种种不断的要求，中台就像一块海棉，吸收进来后还要排出去给生产的所有相关环节，不只是一种简单的对接，而且对所以需要进行计算，细化，分类，转接成一种标准。</p><p>举了一个养猪的例子做一个类比吧，如果你参加中台建设落地后，想必你对中台会有更深的理解。</p><h2 id="数据中台不是数据平台"><a href="#数据中台不是数据平台" class="headerlink" title="数据中台不是数据平台"></a>数据中台不是数据平台</h2><p>数据中台不是数据平台，数据平台提供了是各种结构化、非结构化的数据集，而数据中台是在数据平台之上，完成企业数据到业务价值的转变。</p><h2 id="数据中台与微服务"><a href="#数据中台与微服务" class="headerlink" title="数据中台与微服务"></a>数据中台与微服务</h2><p>数据中台方向上为了满足前端带来的各种需求；而微服务是后端各种对象的整合。</p><h2 id="对于中台的定义"><a href="#对于中台的定义" class="headerlink" title="对于中台的定义"></a>对于中台的定义</h2><p>ThoughtWorks首席咨询师王健对中台的定义是：<strong>企业级能力复用平台</strong>，它包括：企业级、能力、复用及平台。</p><ul><li>企业级说明了中台范围</li><li>能力说明了承载的对象</li><li>复用说明了中台的核心价值</li><li>平台说明了中台的主要形式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="数据中台" scheme="https://yudading.github.io/categories/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/"/>
    
    
      <category term="什么是中台" scheme="https://yudading.github.io/tags/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记-01</title>
    <link href="https://yudading.github.io/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
    <id>https://yudading.github.io/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</id>
    <published>2020-08-05T13:52:41.000Z</published>
    <updated>2020-08-05T14:22:54.792Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1466027974&auto=1&height=66"></iframe><h1 id="玩转C语言程序设计-01"><a href="#玩转C语言程序设计-01" class="headerlink" title="玩转C语言程序设计_01"></a>玩转C语言程序设计_01</h1><p>大家好，我是大丁，本系列记录为学习C语言的笔记，下面的代码和笔记都来自于《玩转C语言程序设计》这本书，此系列笔记只用于学习交流。</p><p><img src="/2020/08/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/114.png" alt="114"></p><h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><h3 id="1-puthchar-函数"><a href="#1-puthchar-函数" class="headerlink" title="1 puthchar() 函数"></a>1 puthchar() 函数</h3><p>每次只能向显示输出设备输出单个字符，该函数的原型包含在stdio.h头文件中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int putchar(int ch);</span><br></pre></td></tr></table></figure><h4 id="实例01-输出“小猪”表情"><a href="#实例01-输出“小猪”表情" class="headerlink" title="实例01 输出“小猪”表情"></a>实例01 输出“小猪”表情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char c1 &#x3D; &#39;(&#39;,c2 &#x3D; &#39;-&#39;,c3 &#x3D; &#39;o&#39;,c4 &#x3D; &#39;)&#39;;</span><br><span class="line">putchar(c1);</span><br><span class="line">putchar(c2);</span><br><span class="line">putchar(c1);</span><br><span class="line">putchar(c3);</span><br><span class="line">putchar(c3);</span><br><span class="line">putchar(c4);</span><br><span class="line">putchar(c2);</span><br><span class="line">putchar(c4);</span><br><span class="line">putchar(&#39;\n&#39;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看"><a href="#运行查看" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./01</strong> </p><blockquote><p>(-(oo)-)</p></blockquote><hr><h3 id="2-puts-函数"><a href="#2-puts-函数" class="headerlink" title="2 puts() 函数"></a>2 puts() 函数</h3><p>一次可以输出多个字符，可用来输出一个字符串到显示屏幕上，它也在stdio.h的函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int puts(char *str);</span><br></pre></td></tr></table></figure><h4 id="实例02-跟我一起来说绕口令"><a href="#实例02-跟我一起来说绕口令" class="headerlink" title="实例02 跟我一起来说绕口令"></a>实例02 跟我一起来说绕口令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">puts(&quot;粉红墙上事凤凰，凤凰画在粉红墙&quot;);</span><br><span class="line">puts(&quot;红凤凰、粉凤凰，红粉凤凰、花凤凰&quot;);</span><br><span class="line">puts(&quot;红凤凰、黄凤凰，红粉凤凰，粉红凤凰，花粉花凤凰&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-1"><a href="#运行查看-1" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./02</strong></p><p>粉红墙上事凤凰，凤凰画在粉红墙</p><p>红凤凰、粉凤凰，红粉凤凰、花凤凰</p><p>红凤凰、黄凤凰，红粉凤凰，粉红凤凰，花粉花凤凰</p><hr><h3 id="3-printf-函数"><a href="#3-printf-函数" class="headerlink" title="3 printf() 函数"></a>3 printf() 函数</h3><p>是控制格式的输出函数，也在stdio.h函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(格式控制，输出列表)；</span><br></pre></td></tr></table></figure><ol><li>格式控制是用双引号括起来的字符串，此处也称为转换控制字符串，其中包括格式字符和普通字符两种格式。</li></ol><ul><li>格式字符用来对格式进行说明，其作用是将输出的数据转换为指定的格式输出。格式字符以“%”字符开头。</li><li>普通字符是需要按照原样输出的字符，其中包括双引号内的逗号、空格和换行符。</li></ul><ol start="2"><li>输出列表</li></ol><p>输出列表框列出的是要进行输出的一些数据，其形式可以是变量或表达式。<br>例如，要输出一个整型变量的语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int iInt &#x3D; 521;</span><br><span class="line">printf(&quot;%d I love You&quot;, iInt);</span><br></pre></td></tr></table></figure><p>执行上面的语句显示结果是“521 I Love You”, 其中 I Love You 是普通字符串，而“%d”就格式字符，表示输出的是后面的iInt的数据。</p><h4 id="实例03-鸡兔同笼问题"><a href="#实例03-鸡兔同笼问题" class="headerlink" title="实例03 鸡兔同笼问题"></a>实例03 鸡兔同笼问题</h4><p>鸡、兔关在同一个笼子里，已知有35个头、94只脚，问笼子里有几只鸡、几只兔。计算代码如下：</p><p>鸡的数量 =（4*鸡兔总头数 - 鸡兔总脚数）/2； 兔的数量 = （鸡兔总脚数 - 2 * 鸡兔总头数）/2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int feet&#x3D;94,head&#x3D;35,Chicken,Rabbit;</span><br><span class="line">Chicken &#x3D; (4 * head - feet) &#x2F; 2;</span><br><span class="line">Rabbit &#x3D; (feet - 2 * head) &#x2F; 2;</span><br><span class="line">printf(&quot;笼中有%d只鸡，有%d只兔子！\n&quot;, Chicken,Rabbit);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-2"><a href="#运行查看-2" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./03</strong></p><p>笼中有23只鸡，有12只兔子！</p><hr><h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><h3 id="1-getchar-函数"><a href="#1-getchar-函数" class="headerlink" title="1 getchar() 函数"></a>1 getchar() 函数</h3><p>每次只能从终端（输入设备）输入一个字符，这个函数的原型包括在stdio.h头文件中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int getchar();</span><br></pre></td></tr></table></figure><p>getchar()函数与puthchar()函数的区别是前者没有参数，例如从输入设备得到一个字符给字符变量cChar,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cChar&#x3D;getchar();</span><br></pre></td></tr></table></figure><h4 id="实例04-字母大小写的秘密"><a href="#实例04-字母大小写的秘密" class="headerlink" title="实例04 字母大小写的秘密"></a>实例04 字母大小写的秘密</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char c1,c2;</span><br><span class="line">printf(&quot;请输入一个小写字母：\n&quot;);</span><br><span class="line">c1 &#x3D; getchar();</span><br><span class="line">c2 &#x3D; c1 - 32;</span><br><span class="line">printf(&quot;转换以后的字母：%c\n&quot;, c2);</span><br><span class="line">return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-3"><a href="#运行查看-3" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./04</strong></p><p>请输入一个小写字母：<br>a<br>转换以后的字母：A</p><hr><h3 id="2-get-函数"><a href="#2-get-函数" class="headerlink" title="2 get()函数"></a>2 get()函数</h3><p>get()函数也是输入函数，它能向终端输入一个字符串，该函数也在stdio.h的函数库中，一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><p>其中str字符串指针变量为形式参数，作用是将读取的字符串保存在形式参数str变量中。例如，定义字符数组变量cString,然后使用gets()函数获取输入字符的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(cString);</span><br></pre></td></tr></table></figure><h4 id="实例05-模拟用户登录"><a href="#实例05-模拟用户登录" class="headerlink" title="实例05 模拟用户登录"></a>实例05 模拟用户登录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char cString[20];</span><br><span class="line">puts(&quot;请输入账号：&quot;);</span><br><span class="line">gets(cString);</span><br><span class="line">puts(&quot;您输入的账号为：&quot;);</span><br><span class="line">puts(cString);</span><br><span class="line">puts(&quot;请输入密码：&quot;);</span><br><span class="line">gets(cString);</span><br><span class="line">puts(&quot;您输入的密码为: &quot;);</span><br><span class="line">puts(cString);</span><br><span class="line">puts(&quot;您的账号登录为：&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-4"><a href="#运行查看-4" class="headerlink" title="运行查看"></a>运行查看</h4><blockquote><p>05.c:7:2: warning: implicit declaration of function ‘gets’; did you mean ‘fgets’?</p></blockquote><p>[-Wimplicit-function-declaration]<br>    7 |  gets(cString);<br>      |  ^<del>~</del><br>      |  fgets</p><p>/usr/bin/ld: /tmp/ccUgXpJA.o: in function <code>main&#39;:05.c:(.text+0x34): warning: the</code>gets’ function is dangerous and should not be used.</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>gets是从标准输入设备读取字符串的函数，函数原型 char * gets ( char * str );  刚开始学习C语言时觉得gets这个函数相当的好用，因为他比scanf写起来要短，而且可以输入有空格的字符串。但是越往后学就会发现，在C语言中用GCC编译使用了gets函数的源文件，编译器会给警告。<br>原因是gets可以无限读取，不会判断上限，如果无限输入会造成栈空间溢出，在程序返回时，不能正常的找到返回地址，程序将发生不可预测行为。如果用了gets，像我们现在写的小程序可能在PC端上会闪退，但如果在大型项目中就会造成很严重的损失。因此我们应该尽量避免使用gets函数，顺便一提在2011年12月，ANSI 采纳了 ISO/IEC 9899:2011 标准，标准中删除了 gets()函数，使用一个新的更安全的函数gets_s()替代。<br>————————————————<br>版权声明：本文为CSDN博主「画地」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42201172/article/details/81259229" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42201172/article/details/81259229</a></p><hr><h3 id="3-scanf-函数"><a href="#3-scanf-函数" class="headerlink" title="3 scanf() 函数"></a>3 scanf() 函数</h3><p>功能是指定固定的格式，并且按照指定的格式接收用户在键盘上输入的数据，最后将数据存储在指定的变量中。一般形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(格式控制，地址列表);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d,&amp;iInt&quot;);</span><br></pre></td></tr></table></figure><p>“&amp;”符号表示取iInt变量的地址，在编写代码时不用关心变量的地址具体是多少，只要在代码中变量的标识符前加”&amp;”就表示获取变量的地址。</p><h4 id="实例06-用C程序输出《拍手歌》"><a href="#实例06-用C程序输出《拍手歌》" class="headerlink" title="实例06 用C程序输出《拍手歌》"></a>实例06 用C程序输出《拍手歌》</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int beat;</span><br><span class="line">puts(&quot;请输入你想拍几：&quot;);</span><br><span class="line">scanf(&quot;%d&quot;, &amp;beat);</span><br><span class="line">printf(&quot;你拍%d, 我拍%d\n&quot;, beat, beat);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行查看-5"><a href="#运行查看-5" class="headerlink" title="运行查看"></a>运行查看</h4><p><strong>ydd@ydd:~/c$ ./06</strong></p><p>请输入你想拍几：</p><p>1</p><p>你拍1, 我拍1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="C语言学习笔记" scheme="https://yudading.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="玩转C语言程序设计" scheme="https://yudading.github.io/tags/%E7%8E%A9%E8%BD%ACC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="玩转C语言程序设计chapter1" scheme="https://yudading.github.io/tags/%E7%8E%A9%E8%BD%ACC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1chapter1/"/>
    
  </entry>
  
  <entry>
    <title>性能调优01</title>
    <link href="https://yudading.github.io/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/"/>
    <id>https://yudading.github.io/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/</id>
    <published>2020-08-05T13:19:35.000Z</published>
    <updated>2020-08-05T14:23:20.602Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29004400&auto=0&height=66"></iframe><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><p>您好，我是大丁，这次和大家聊聊有关性能调忧，性能调优是一个很大的领域也包括了很多相关的概念，今天先说三个重要的概念，就是进程、线程、和协程。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。</p></blockquote><blockquote><p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p></blockquote><blockquote><p>进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。 [3]<br>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念,所有多道程序设计操作系统都建立在进程的基础上。</p></blockquote><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><strong>操作系统引入进程的概念的原因:</strong><br>从理论角度看，是对正在运行的程序过程的抽象；<br>从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。<br>特征</p><ul><li>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</li><li>并发性：任何进程都可以同其他进程一起并发执行</li><li>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</li><li>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</li><li>结构特征：进程由程序、数据和进程控制块三部分组成。</li></ul><p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。<br>线程是独立调度和分派的基本单位。线程可以为操作系统内核调度的内核线程，如Win32线程；</p><p>由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。</p><p>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p><p>一个进程可以有很多线程，每条线程并行执行不同的任务。</p><p>在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><h3 id="与进程比较"><a href="#与进程比较" class="headerlink" title="与进程比较"></a>与进程比较</h3><p><strong>线程与进程的区别可以归纳为以下4点：</strong></p><ol><li>地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li>在多线程OS中，进程不是一个可执行的实体。</li></ol><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>协程</strong>不是进程或线程，其执行过程更类似于子例程，或者说不带返回值的函数调用。</p><p>一个程序可以包含多个协程，可以对比与一个进程包含多个线程，因而下面我们来比较协程和线程。</p><p>我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，<br>但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。</p><p>看一下三者的关系：</p><p><img src="/2020/08/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/2058.png" alt="2058"></p><h3 id="举生活中的例子"><a href="#举生活中的例子" class="headerlink" title="举生活中的例子"></a>举生活中的例子</h3><p><strong>进程、线程、协程对比 :</strong></p><ul><li><p>有一个老板想要开个工厂进行生产某件商品（例如剪子）</p></li><li><p>他需要花一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的为了能够生产剪子而准备的资源称之为：进程</p></li><li><p>只有生产线是不能够进行生产的，所以老板的找个工人来进行生产，这个工人能够利用这些材料最终一步步的将剪子做出来，这个来做事情的工人称之为：线程</p></li><li><p>这个老板为了提高生产率，想到3种办法：</p></li></ul><p>在这条生产线上多招些工人，一起来做剪子，这样效率是成倍増长，即单进程 多线程方式</p><p>老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了些财力物力购置了另外一条生产线，然后再招些工人这样效率又再一步提高了，即多进程 多线程方式</p><p>老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时临时没事或者再等待某些条件（比如等待另一个工人生产完某道工序之后他才能再次工作）。</p><p>那么这个员工就利用这个时间去做其它的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：<strong>协程方式</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>准备工作：创建一个APP，延迟3秒后输出‘hello’.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask     # pip install flask</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    time.sleep(3)    # 休眠 3 秒再返回结果</span><br><span class="line">    return &#39;Hello!&#39;</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run(threaded&#x3D;True)  # 以多线程模式启动服务</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"># 用于多进程</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"># 用于多线程</span><br><span class="line">from threading import Thread</span><br><span class="line"># 用于协程+异步</span><br><span class="line">import asyncio</span><br><span class="line">import aiohttp      # pip install aiohttp</span><br><span class="line"></span><br><span class="line">urls &#x3D; [&#39;http:&#x2F;&#x2F;127.0.0.1:5000&#39; for _ in range(10)]</span><br><span class="line"></span><br><span class="line">def get_html_text(url):</span><br><span class="line">    response &#x3D; requests.get(url)</span><br><span class="line">    return response.text</span><br><span class="line"></span><br><span class="line"># 单进程</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">for url in urls:</span><br><span class="line">    result &#x3D; get_html_text(url)</span><br><span class="line">    print(result)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【单进程单线程】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 多进程 + 并行</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">processes &#x3D; []</span><br><span class="line">for url in urls:</span><br><span class="line">    p &#x3D; Process(target&#x3D;get_html_text, args&#x3D;(url,))</span><br><span class="line">    processes.append(p)</span><br><span class="line">    p.start()</span><br><span class="line">for p in processes:</span><br><span class="line">    p.join()</span><br><span class="line">    print(&#39;Hello!&#39;)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【多进程  并行】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 多线程 + 并发</span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">threads &#x3D; []</span><br><span class="line">for url in urls:</span><br><span class="line">    t &#x3D; Thread(target&#x3D;get_html_text, args&#x3D;(url,))</span><br><span class="line">    threads.append(t)</span><br><span class="line">    t.start()</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">    print(&#39;Hello!&#39;)</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【多线程  并发】耗时：%s 秒&#39; %(end - start))</span><br><span class="line"></span><br><span class="line"># 协程 + 异步</span><br><span class="line"># 因为 requests 模块不支持异步操作，需要借助 aiohttp 模块</span><br><span class="line">async def get_html_text_async(url):</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        async with session.get(url) as response:</span><br><span class="line">            text &#x3D; await response.text()</span><br><span class="line">            return text</span><br><span class="line"></span><br><span class="line">start &#x3D; time.time()</span><br><span class="line">tasks &#x3D; [asyncio.ensure_future(get_html_text_async(url)) for url in urls]</span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">for task in tasks:</span><br><span class="line">    print(task.result())</span><br><span class="line">end &#x3D; time.time()</span><br><span class="line">print(&#39;【协程 ++ 异步】耗时：%s 秒&#39; %(end - start))</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【单进程单线程】耗时：30.076159238815308 秒</span><br><span class="line">【多进程  并行】耗时：31.149558782577515 秒</span><br><span class="line">【多线程  并发】耗时：3.0131824016571045 秒</span><br><span class="line">【协程 ++ 异步】耗时：3.0092201232910156 秒</span><br></pre></td></tr></table></figure><h3 id="相关内容链接"><a href="#相关内容链接" class="headerlink" title="相关内容链接"></a>相关内容链接</h3><p><a href="https://blog.csdn.net/hairetz/article/details/16119911" target="_blank" rel="noopener">csdn</a></p><p><a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">csdn</a></p><p><a href="https://juejin.im/post/6844903607892967432" target="_blank" rel="noopener">掘金</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=
      
    
    </summary>
    
    
      <category term="性能调优01" scheme="https://yudading.github.io/categories/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801/"/>
    
    
      <category term="进程" scheme="https://yudading.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="https://yudading.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="协程" scheme="https://yudading.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>DevOps_01 DevOps是什么？</title>
    <link href="https://yudading.github.io/2020/07/22/DevOps-01/"/>
    <id>https://yudading.github.io/2020/07/22/DevOps-01/</id>
    <published>2020-07-21T16:30:23.000Z</published>
    <updated>2020-07-21T17:50:42.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>大家好，我是大丁，很高兴在这里和大家聊聊DevOps，2020年对我而言是如此地深刻，不只是疫情的原因，虽然在家里有了一些自己的时间，不用每天早起站公交挤地铁，可是人一旦休息久了也会心生厌倦，不过也好，最少有时间让自己放松起来，想想这些年的工作过往，自己做了什么，有哪些收获？技术上提高了多少？踏过多少的坑？就此，与有缘的你分享一下我的过往吧，如果你同我如前浪，望指正，如你是后浪，如你看过我的文字能有收获，那我就很开心了！</p><h1 id="DevOps是什么？"><a href="#DevOps是什么？" class="headerlink" title="DevOps是什么？"></a>DevOps是什么？</h1><h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><blockquote><p>DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>DevOps是外来品，有着太多的属性，下面说说我的个人理解，DevOps它是一种工作方式也是一种文化，对企业而言，它可能是一个团队，也可能是一种口号，可以是公司正在招聘的一个职位，可以是你必须使用的一套相关的工具，可以是技术人员要达到的一种目标，总之，近几年，这个DevOps大火，互联网也好，物联网也罢，如果不选择DevOps，只能说明你所在的公司落后了，要不就是技术人员太low了。</p><p>它包含了不只是通过开发与运维的紧密合作来提高效率，还包括了相关的持续集成、持续发布相关的技术和工具，它需要持续改善的运维架构等等，而这一切都要在结合企业业务的真正实践上，并且你只能借鉴别人，但不能照搬，因为没有哪两个公司是一模一样的。</p><p>我的团队对外就是DevOps，在我的团队中的同事以前有的是做纯开发工作的，也有是做传统运维的，而DevOps的出现，模糊了二者之间的界线，与以前开发与运维关系完全不同，在公司中我做为运维人员要不断的对接开发同事，不只是为他们搭建开发、升级、发布的环境，也要做过上线后的维护，而对开发人员也要和我保持有效的沟通，以便让他们的代码迅速上线。<br>举个真实的过往例子，早期我负责升级工作，当时公司有小三十个服务，它们之间有很强的耦合，当时还是处在脚本化的情况下，我写好了脚本对开发同事的代码进行解包，打包，上传AWS存储，再利用相关的命令行提交服务器等等一系列操作，记得有一天有四十多次升级，是的，四十多次，那天我几乎没做别的工作，一直做升级的事，升级后还要看是否升级成功，服务是否有问题，那天的工作量一想起来就有些上头。</p><p>痛过了，才让人思考，怎么才能减少这种工作量呢？如何自动化升级，怎么样才能让开发人员做一些操作，让运维人员把更多的精力放在维护上呢？如何让开发人员做一些升级的工作他们愿意吗？有些开发人员会觉得只要我代码没问题交给运维就好，出了问题都是运维的责任，这样也造成了开发与运维的恶化关系，所以那时我的工作重点放在了和开发人员好好的沟通上，说明白了相互的具体操作，让公司技术老大来推动，把所有相关的操作编写成文档，明确了各自的责任，同时优化了升级流程，选用了主流的开源工具。</p><p>这样一切规范下来，就不那么痛苦了。在那个时候我对DevOps的体会就是：在现在快速迭代的大环境下，为了提高生产效率，需要两者紧密的合作，说白了<strong>就是想办法减少开发与运维之间的隔阂带来的消耗，提高开发速度，快速上线，不断迭代，它需要开发与运维人员之间良好的沟通</strong>。</p><p>随着工作的不断深入，我也有了更深的体会，现在让我说DevOps到底是什么呢？</p><p>在这里我想说<strong>DevOps解决的是人与人之间的关系，即Dev（开发）和Ops（运维），就是利用相互灵活的关系完成流程化、工具的不断优化，强调精益，减少浪费，快速交付，提供给用户功能体验</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h1&gt;&lt;p&gt;大家好，我是大丁，很高兴在这里和大家聊聊DevOps，2020年对我而言是如此地深刻，不只是疫情的原因，虽然在家里有了一些自己的时间，不用每
      
    
    </summary>
    
    
      <category term="DevOps" scheme="https://yudading.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://yudading.github.io/tags/DevOps/"/>
    
      <category term="DevOps是什么？" scheme="https://yudading.github.io/tags/DevOps%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    
  </entry>
  
</feed>
